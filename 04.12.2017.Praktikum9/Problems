1. Проверка дали съществува път от корена до листо в дърво
вход: дърво от букви
вход: низ
изход: дали има път от корена до листо в дървото, представен от низа
// b y a y b y x y a n n y y n y z n n y a n n n y u y u n y u n n n
/*
             b
            / \
           a   u
          /   /
         b   u
        / \   \
       x   a   u
      / \
     a   y
          \
           z
*/

1*. 1. Проверка дали дадена дъма се съдържа в път от корена на дървото до листото
вход: дърво от букви
вход: низ
изход: дали има път от корена до листо в дървото, представен от низа
// b y a y b y x y a n n y y n y z n n y a n n n y u y u n y u n n n
    /*
             b
            / \
           a   u
          /   /
         b   u
        / \   \
       x   a   u
      / \
     a   y
          \
           z
           
    "baba  == 1" 
    "buuu  == 1" 
    "ba  == 0" 
    "babx  == 0" 
    "babxy  == 0" 
  */
  
2. Проверка за път равен на сума
вход: дърво от цели числа
вход: число, представяващо сумата на търсения път
изход: път, сумата на чийто възли е равна на въведеното число
// input: 1 y 2 y 3 y 5 n n n y 4 y 6 n n y 7 n n y 0 y 11 n n y 32 n n
// expected: 273

3. Изчислете израза, представен в двоично дърво по следния начин: израз: (5 + 2) * (10 -3) * 4 - 5.
 /*
                -
               /\
              *  5
            /  \
           *    4
         /   \
        +     -
       /\     /\
      5  2  10  3
 */
 
4. Дадени са две двоични дървета с еднаква структура – дърво от числа и дърво от операции,
представени със символите +, - и *. По-долу са дадени примери за такива дървета.

Дърво от числа:
      ч1
      /    \
    ч2   ч3
    /   \     \
  ч4  ч5  ч6

Дърво от операции:
       оп1
       /    \
   оп2   оп3
    /   \       \
оп4 оп5  оп6

Да се напише функция, която пресмята сумата:
    n
si
   i = 1

където n е броят на върховете в кое да е от дърветата, Si = Чi ОПi Ci,
а Ci е броят на върховете в поддървото с корен върха Чi (включително върха Чi).
Пример:

Дърво от числа:
     5
   /    \
  4     1
 /   \     \
3    2   10


Дърво от операции:
    *
   /  \
  +   -
 /   \   \
+    *   -

Резултат: (5 * 6) + (4 + 3) + (1 – 2) + (3 + 1) + (2 * 1) + (10 – 1).

5. Имаме двоично дърво, незадължително пълно. Да се предложи алгоритъм проверяващ
дали дървото е огледално-симетрично.

Примери:
1)  
     1
     / \     -> false
   2   3

2)
      1
     /  \
    2   2   -> true
   /      \
  3       3

6. Дадено е двоично дърво и ниво k в дървото. Да се провери дали стойностите във върховете на дървото, 
намиращи се на ниво k, образуват палиндром (нивата се броят от нула, т.е. коренът на дървото се намира на ниво 0,
неговите преки наследници на ниво 1 и т. нат.).

Примери:
1)
            1
           /   \     -> false
          2    3
         
         1



2)
                   1
                 /     \
               3      7   -> true
              /  \    /   \
            1   2  2    1
           
           2
